1. Move 메서드

1) 방향 벡터 계산:

curMovementInput는 OnMove 메서드에서 설정되는 입력 값입니다.

transform.forward * curMovementInput.y는 전후 방향으로의 입력(W, S 키 등)을 의미하고, 

transform.right * curMovementInput.x는 좌우 방향으로의 입력(A, D 키 등)을 의미합니다.

두 값을 더하여, 현재 입력 방향에 따른 이동 벡터 dir을 계산합니다.

2) 속도 곱셈:

계산된 이동 방향 벡터 dir에 moveSpeed를 곱하여 실제 이동 속도를 반영합니다.

3) y축 속도 유지:

중력이나 점프 등으로 인해 y축의 속도가 변화할 수 있으므로, 현재 리지드바디의 y축 속도를 유지하면서 dir의 y축 값을 _rigidbody.velocity.y로 설정합니다.

4) 리지드바디의 속도 설정:

리지드바디의 속도를 계산된 dir 값으로 설정하여, 플레이어를 해당 방향으로 이동시킵니다.

2. CameraLook 메서드

1) X축 회전 변경:

camCurXRot에 mouseDelta.y(마우스의 세로 움직임)와 lookSensitivity(감도)를 곱한 값을 더합니다. 이 값은 카메라의 현재 X축 회전값입니다.
이를 통해 마우스를 위아래로 움직일 때, X축 회전이 변경됩니다.

2) 회전 제한 (Clamp):

Mathf.Clamp를 사용하여 camCurXRot를 minXLook과 maxXLook 사이로 제한합니다. 이를 통해 플레이어가 너무 위나 아래를 볼 수 없게 합니다.

3) 카메라 회전 적용:

cameraContainer의 로컬 회전을 -camCurXRot 값으로 설정하여, 위에서 계산한 값을 카메라의 X축 회전에 반영합니다. Y축과 Z축은 변화가 없습니다.

4) 플레이어 회전 적용:

플레이어 오브젝트의 Y축 회전값에 mouseDelta.x(마우스의 가로 움직임)와 lookSensitivity를 곱한 값을 더하여, 좌우 회전 효과를 줍니다. 이는 플레이어가 마우스를 좌우로 움직일 때, 회전하는 효과를 줍니다.

3. IsGrounded 메서드

1) 4개의 Ray 설정:

네 개의 Ray를 생성합니다. 각 Ray는 플레이어의 중심에서 약간의 오프셋을 두고 생성되며, 모두 아래 방향(Vector3.down)으로 향합니다.
오프셋 위치는 다음과 같습니다:
transform.forward * 0.2f: 앞쪽으로 약간 이동한 위치.
-transform.forward * 0.2f: 뒤쪽으로 약간 이동한 위치.
transform.right * 0.2f: 오른쪽으로 약간 이동한 위치.
-transform.right * 0.2f: 왼쪽으로 약간 이동한 위치.
각 Ray의 y축 위치는 살짝 위(transform.up * 0.01f)에서 시작합니다.

2) Raycast 검사:

각 Ray를 사용하여 Physics.Raycast를 호출합니다. Ray가 0.1f 거리 내에서 groundLayerMask에 해당하는 충돌체를 감지하면, true를 반환하여 플레이어가 착지 상태임을 나타냅니다.

3) 모든 Ray가 실패한 경우:

모든 Ray가 충돌하지 않는 경우, false를 반환하여 플레이어가 공중에 있음을 나타냅니다.

CampFire

1. Start 메서드

InvokeRepeating 메서드는 특정 메서드를 지속적으로 호출하는 Unity의 내장 함수입니다.
"DealDamage" 메서드를 첫 호출을 지연 없이(0초) 호출하고, 이후에는 damageRate 간격마다 반복 호출합니다.
이를 통해 DealDamage 메서드는 정해진 간격마다 자동으로 실행됩니다.

2. DealDamage 메서드

반복문을 통해 things 리스트에 있는 모든 객체를 순회합니다.
각 객체가 IDamagable 인터페이스를 구현하고 있으므로, TakePhysicalDamage 메서드를 호출하여 데미지를 줍니다. 이때 전달되는 데미지는 damage 변수로 지정된 값입니다.
이 메서드는 한 번 호출될 때마다 리스트에 있는 모든 객체에 데미지를 적용합니다.

3. OnTriggerEnter 메서드

OnTriggerEnter는 Unity의 콜라이더가 트리거로 설정된 상태에서, 다른 콜라이더가 해당 트리거 영역에 진입했을 때 호출되는 메서드입니다.
TryGetComponent를 사용하여, 트리거에 진입한 객체(other)가 IDamagable 인터페이스를 구현하고 있는지 확인합니다.
만약 other 객체가 IDamagable 인터페이스를 구현하고 있다면, damagable 변수에 그 객체를 할당하고, things 리스트에 추가합니다.

4. OnTriggerExit 메서드

OnTriggerExit는 Unity의 콜라이더가 트리거로 설정된 상태에서, 다른 콜라이더가 해당 트리거 영역에서 나갔을 때 호출되는 메서드입니다.
TryGetComponent를 사용하여, 트리거에서 나간 객체가 IDamagable 인터페이스를 구현하고 있는지 확인합니다.
만약 other 객체가 IDamagable 인터페이스를 구현하고 있다면, things 리스트에서 해당 객체를 제거합니다.

DamageIndicator 

1. Start 메서드


Start 메서드는 Unity의 MonoBehaviour 클래스에서 초기화 시 호출됩니다.
CharacterManager.Instance.Player.condition.onTakeDamage:
CharacterManager의 싱글톤 인스턴스에서 현재 Player의 condition 객체에 접근합니다. 이 condition 객체에는 onTakeDamage라는 델리게이트 이벤트가 있습니다.
플레이어가 데미지를 받을 때 호출되는 이벤트인 onTakeDamage에 Flash 메서드를 구독시킵니다.
결과적으로 플레이어가 데미지를 받을 때마다 Flash 메서드가 호출됩니다.

2. Flash 메서드

기존 코루틴 중지:

만약 coroutine이 null이 아니라면, 이전에 실행 중이던 코루틴이 존재하므로 **StopCoroutine**을 호출하여 해당 코루틴을 중지시킵니다.
이는 이전의 플래시 효과가 아직 끝나지 않았더라도 새로운 플래시 효과가 적용될 수 있도록 합니다.

이미지 활성화 및 색상 설정:

image.enabled = true를 통해, 이미지가 활성화됩니다.
image.color를 설정하여 빨간색으로 플래시 효과의 초기 색상을 지정합니다. Color 값은 (1f, 100f / 255f, 100f / 255f)로, 빨간색의 RGB 값을 나타냅니다.

FadeAway 코루틴 실행:

StartCoroutine을 통해 FadeAway 코루틴을 실행하고, 해당 코루틴을 coroutine 변수에 저장하여 이후에 중지하거나 관리할 수 있게 합니다.

3. FadeAway 코루틴

투명도 설정:

startAlpha를 0.3f로 설정하여, 초기 투명도를 결정합니다. 이 값을 a 변수에 할당합니다.

반복문을 통한 투명도 감소:

while (a > 0) 조건으로 투명도가 0보다 클 때까지 반복합니다.
각 반복에서 a 값은 (startAlpha / flashSpeed) * Time.deltaTime 만큼 감소됩니다.
여기서 flashSpeed는 플래시 효과가 얼마나 빨리 사라질지를 결정하는 속도이며, Time.deltaTime을 곱하여 프레임당 일정한 속도로 감소하도록 합니다.

색상 및 투명도 업데이트:

이미지의 색상(image.color)을 업데이트하면서, 알파 값을 현재 투명도(a)로 설정하여 점진적으로 사라지도록 만듭니다.

반복문 종료 후 이미지 비활성화:

투명도가 0 이하로 내려가면 while 루프를 빠져나오고, 이미지의 enabled 속성을 false로 설정하여 이미지가 비활성화됩니다.

Interaction

1. Start 메서드

이 메서드는 Unity의 MonoBehaviour에서 초기화 단계에서 호출됩니다.
Camera.main을 사용하여 현재 씬의 메인 카메라를 _camera 변수에 할당합니다.

2. Update 메서드

상호작용 체크 주기 확인:

Time.time - lastCheckTime > checkRate 조건을 통해 마지막 체크 시간과의 간격을 비교합니다. 일정 시간이 지났다면, 체크를 진행합니다.
lastCheckTime을 현재 시간(Time.time)으로 업데이트하여 다음 체크를 대기합니다.

레이캐스트 생성:

Screen.width / 2와 Screen.height / 2를 사용하여 화면의 중앙 좌표를 계산합니다.
_camera.ScreenPointToRay를 통해 화면 중앙에서 출발하는 레이를 생성합니다.

레이캐스트 충돌 체크:

Physics.Raycast(ray, out hit, maxCheckDistance, layerMask)를 통해 생성한 레이가 지정된 maxCheckDistance와 layerMask를 고려하여 충돌 검사를 합니다.
레이가 충돌한 경우, 충돌한 오브젝트(hit.collider.gameObject)가 현재 상호작용 대상(curInteractGameObject)과 다른지 확인합니다.

상호작용 대상 변경:

충돌한 오브젝트가 현재 상호작용 대상과 다른 경우, curInteractGameObject를 업데이트하고, 해당 오브젝트의 IInteractable 인터페이스를 얻어 curInteractable 변수에 저장합니다.
이후, SetPromptText 메서드를 호출하여 상호작용 프롬프트를 업데이트합니다.

상호작용 대상 초기화:

레이가 충돌하지 않은 경우, curInteractGameObject와 curInteractable을 null로 설정하고, 프롬프트 텍스트를 비활성화하여 더 이상 프롬프트가 보이지 않도록 합니다.

3. SetPromptText 메서드

프롬프트 텍스트 활성화:

promptText.gameObject.SetActive(true)를 호출하여, 프롬프트 텍스트를 활성화합니다.

프롬프트 텍스트 설정:

curInteractable.GetInteractPrompt()를 호출하여 현재 상호작용 가능한 오브젝트로부터 프롬프트 문자열을 얻습니다.
얻어온 프롬프트 문자열을 promptText.text에 설정하여, UI에 표시되도록 합니다.

4. OnInteractInput 메서드

입력 이벤트 체크:

context.phase == InputActionPhase.Started 조건을 통해, 상호작용 입력이 시작되었는지 확인합니다.

상호작용 가능 대상 확인:

curInteractable이 null이 아닌지 확인합니다. 이는 상호작용 가능한 오브젝트가 현재 존재하는지 확인하는 과정입니다.

상호작용 수행:

curInteractable.OnInteract()를 호출하여 현재 상호작용 대상의 상호작용 로직을 수행합니다.

상호작용 대상 초기화:

상호작용이 완료된 후, curInteractGameObject와 curInteractable을 null로 설정하여 현재 상호작용 대상을 초기화합니다.
프롬프트 텍스트를 비활성화하여 더 이상 상호작용이 필요하지 않음을 표시합니다.

UIInventory

1. Start 메서드

플레이어 관련 컴포넌트 초기화:

CharacterManager의 인스턴스에서 플레이어의 controller, condition, dropPosition을 가져옵니다.

이벤트 연결:

controller의 inventory 이벤트에 Toggle 메서드를, Player의 addItem 이벤트에 AddItem 메서드를 연결합니다.

인벤토리 창 비활성화:

게임 시작 시 인벤토리 창을 비활성화합니다.

슬롯 초기화:

slotPanel의 자식 개수만큼 slots 배열을 생성하고, 각 자식의 ItemSlot 컴포넌트를 가져와 배열에 저장합니다.
슬롯의 인덱스와 인벤토리 참조를 설정합니다.

선택된 아이템 창 초기화:

선택된 아이템 정보 창을 초기화하여, 모든 UI 텍스트와 버튼을 비활성화합니다.

2. AddItem 메서드

아이템 스택 처리:

플레이어가 추가하려는 아이템(data)이 스택 가능한 경우, GetItemStack 메서드를 통해 같은 종류의 아이템을 찾습니다.
같은 종류의 아이템이 있으면 해당 슬롯의 quantity를 증가시키고, UI를 업데이트합니다.

빈 슬롯에 추가:

스택이 불가능하거나, 같은 종류의 아이템을 찾지 못한 경우, GetEmptySlot 메서드를 통해 빈 슬롯을 찾습니다.
빈 슬롯이 있으면 아이템을 추가하고, 수량을 1로 설정한 후 UI를 업데이트합니다.

아이템 드롭:

빈 슬롯이 없는 경우, 아이템을 현재 위치에서 드롭합니다.

3. UpdateUI 메서드

모든 슬롯을 순회하며, 슬롯에 아이템이 있는 경우 Set 메서드를 호출하여 UI를 업데이트하고, 아이템이 없는 경우 Clear 메서드를 호출하여 슬롯을 비웁니다.

4. SelectItem 메서드

아이템 선택:

선택한 슬롯의 아이템이 null이 아닌지 확인합니다.
아이템 정보를 selectedItem과 selectedItemIndex에 저장합니다.

아이템 정보 업데이트:

선택한 아이템의 이름, 설명, 스탯 정보를 UI에 표시합니다.

버튼 상태 업데이트:

아이템의 유형에 따라 사용 버튼, 장착 버튼, 장착 해제 버튼, 드롭 버튼을 활성화 또는 비활성화합니다.

5. OnUseButton 메서드

아이템 사용:

선택된 아이템이 소모품(Consumable)인지 확인합니다.
아이템의 각 소모품 효과에 따라 플레이어의 상태(condition)를 업데이트합니다.

아이템 제거:

사용 후, 선택된 아이템을 인벤토리에서 제거합니다.
