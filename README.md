Q1.

1) 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.

=> 입문 주차때는 Send Messages, 숙련 주차때는 Invoke Unity Events로 입력을 받았습니다.

입문 주차때는 메서드 호출 시 문자열 이름을 사용하여 호출하는 방식으로 이름의 일치여부가 중요했습니다.

숙련주차때는 이벤트에 직접 메서드를 연결하여 해당 메서드가 존재하는지 확인 할 수 있으며, 메서드 이름을 신경 쓸 필요가 없습니다.

공통점은 모두 런타임에 메서드를 호출하는 동작을 하며, 특정 오브젝트의 메서드와 외부 입력을 연결합니다.

둘다 결국에는 플레이어의 입력을 처리하여 게임 내 오브젝트의 동작을 제어하는데 사용된다는 공통된 목적이 있습니다.

2) CharacterManager와 Player의 역할에 대해 고민해보세요.

=> CharacterManager 클래스는 싱글톤 패턴으로 게임 내의 캐릭터들을 전역적으로 관리하고 접근하는 역할을 합니다.

이 클래스의 목적은 특정 캐릭터(플레이어)를 관리하며, 다른 스크립트에서 해당 플레이어에 쉽게 접근할 수 있도록 하는 것입니다.

Player 클래스는 개별 플레이어 오브젝트에 대한 정보를 관리하고, 다른 컴포넌트들을 모아서 플레이어의 상태와 동작을 제어하는 역할을 합니다.

이 클래스는 플레이어의 행동, 상태, 장비 등을 다루는 핵심 객체입니다.

3) 핵심 로직을 분석해보세요 (Move, CameraLook, IsGrounded)

=> Move의 경우 

CameraLook의 경우 마우스 델타값을 가져와 지정한 최소 최대각 사이에서 움직일 수 있게 잡아주는 메서드입니다. 

IsGrounded의 경우 오브젝트의 동서남북 아래쪽으로 레이를 쏴서 땅에 닫고 있는지 레이로 검사하여 이 오브젝트가 땅에 닿았는지 확인하는 메서드입니다.

레이의 경우 배열로 받아 그 안에 4개의 레이를 생성하여, 4개의 레이는 각각 앞뒤 왼쪽오른쪽에서 밑으로 보내고 있습니다. 

그 레이의 배열을 특정거리 (0.1f)내에서 선택한 (땅) 레이어와 충돌하면 true를 반환하고 있습니다. (4개의 Ray중 하나라도 충돌하면 true)

4) Move와 CameraLook 함수를 각각 FixedUpdate, LateUpdate에서 호출하는 이유에 대해 생각해보세요.

=> Move의 경우 물리엔진 계산이 들어간 메서드로 FixedUpdate에 들어가야 하며,

CameraLook의 경우 움직이고 난 뒤에 계산이 되야 이질감이 없어 LateUpdate에서 호출하는 겁니다.

Q2.

1) 별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.

=> 별도의 UI 스크립트를 만듬으로써 정보 은닉이 가능합니다. 각자의 UI 스크립트는 서로 안에

어떻게 구현되어있는지 알 수가 없습니다. 이럼으로써 각 스크립트간의 결합도는 떨어뜨리며

유지 보수성이 높아집니다. 스크립트 안의 응집도는 높이면서 각 스트립트간의 결합도가 떨어지는건

객체지향적으로 추구하는 방향입니다. (관리방법 : 프리팹으로 만들어서 나중에 인스탄티에이트로

생성하는 방식으로 관리하게 되는데 이로인하여 스크립트를 나눠놓는게 좋습니다.)

2) 인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.

=> 인터페이스의 경우 꼭 들어가야 되는 내용을 미리 구상해놓고, 해당 클래스에 상속시킴으로써

인터페이스에서 미리 구상해놓은 메서드를 상속받은 클래스에서 구현을 해야 클래스가 정상적으로

완성이 됩니다.  IInteractable의 경우 프롬프트의 띄울 내용, 상호작용을 하는 메서드가 명세되어 있

습니다.

3) 핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)

=> UI 스크립트 구조는 플레이어의 상태를 관리하는 컨디션, 데미지를 입었을때 배경색이 바뀌는

데미지 인디케이터, 아이템 슬롯에 어떤 아이콘이 들어가는지 아웃라인을 켜주는지 꺼주는지 작동하

는 아이템슬롯, 각 UI 컨디션 종류를 한군데 모아놓는 UI 컨디션, 실제 인벤토리안에 아이템이 들어와

서 사용하고 장착하고 지우고 버리는 등의 세부적인 기능을 모아놓는 UIInventory로 구성되어 있습

니다. 캠프파이어의 핵심 로직은 캠프파이어의 콜라이더 안으로 들어오게 되면 지속적으로 딜 데미지 메서

드를 호출하여 데미지를 입게 만드는겁니다. 데미지인디케이터의 핵심 로직은 플레이어가 데미지를 입을때

내부 액션으로 Flash 메서드를 전달받아 코루틴을 사용하여 지정해둔 색깔로 지속적으로 호출해주는겁니다.

그러다 데미지를 입지 않으면 코루틴을 중단시켜 다시 원래상태로 돌아가게 합니다.

Q3.

1) Interaction 기능의 구조와 핵심 로직을 분석해보세요.

=> 구조는 크게 업데이트에 실시간으로 레이를 쏴주고, 메서드로는 프롬프트 텍스트(프롬프트 텍스

트의 오브젝트를 켜주고 해당 오브젝트의 이름 설명을 띄워줍니다.), 온인터렉트인풋 (상호작용한 오브젝트를 버튼을

누르면 OnInteract 메서드를 호출하며, 나머지는 다 꺼줍니다.) 이 있습니다. 인터렉션의 핵심 로직은 메인 카메라를

불러와서 카메라가 스크린의 높이 넓이의 2분의 1 지점으로 레이를 발사하여, 해당 오브젝트의 Layer가 일치한다면

설정해둔 프롬프트를 켜게되며, 그렇지 않다면 프롬프트를 끕니다. 또한, 레이를 통해 상호작용 가능한 오브젝트로

판별이 되면 지정해둔 키를 통해 아이템에 추가할 수 있습니다.

[Update 메서드]

현재 시간이 checkRate보다 더 지났다면, 오브젝트 탐지를 시도합니다.

카메라의 중앙에서 화면의 중심을 기준으로 Ray를 발사하여, maxCheckDistance 이내에 있는 오브젝트를 탐지합니다.

Raycast를 통해 오브젝트가 탐지되면, 그 오브젝트가 현재 상호작용 중인 오브젝트(curInteractGameObject)와 다를 경우 이를 갱신하고,

curInteractable을 해당 오브젝트의 IInteractable로 설정합니다.

SetPromptText 메서드를 호출하여, 발견된 오브젝트에 대한 상호작용 텍스트를 설정합니다.

Raycast가 실패하면, 현재 상호작용 가능한 오브젝트를 초기화하고 상호작용 텍스트를 비활성화합니다.

[OnInteractInput 메서드]

InputAction.CallbackContext를 통해 상호작용 입력이 발생했을 때 호출됩니다.

상호작용 입력이 시작 단계(Started)일 때, 현재 상호작용 가능한 오브젝트가 있으면,

해당 오브젝트의 OnInteract 메서드를 호출하여 상호작용을 수행합니다.

상호작용이 끝나면 현재 상호작용 가능한 오브젝트 및 텍스트를 초기화하고 비활성화합니다.

2) Inventory 기능의 구조와 핵심 로직을 분석해보세요.

=> 구조는 크게 스타트 함수에서 모든정보를 초기화해주며, 미리 다 비워두는 함수를 준비하고

아이템 추가, UI 새로고침, 아이템 갯수 추가, 아이템을 선택했을때 띄어주는 이름, 각 버튼에 필요한 

기능 추가, 장비를 입었을때 벗었을때 메서드로 구성 되어 있습니다.

인벤토리의 핵심 로직은 아이템의 추가, 제거, 장착, 해제 등 인벤토리 내의 모든 변동 사항에 대해 UpdateUI 메서드를 호출하여,

슬롯의 상태를 갱신하고, 플레이어에게 현재 인벤토리 상태를 항상 정확하게 보여줍니다.

SelectItem을 통해 선택된 아이템의 정보를 UI에 표시하고, 해당 아이템의 타입에 따라 버튼을 활성화하거나 비활성화합니다.

이로 인해 플레이어는 선택된 아이템에 대한 명확한 피드백을 받을 수 있으며, 아이템의 상호작용 로직이 일관성 있게 유지됩니다.

스택 가능 여부와 최대 스택 수량을 고려하여 아이템을 추가하고, 빈 슬롯을 우선적으로 찾는 등, 인벤토리의 효율적인 관리가 가능합니다.

아이템이 가득 찬 경우에는 자동으로 드롭하도록 구현되어 있어 플레이어 경험을 저해하지 않습니다.
